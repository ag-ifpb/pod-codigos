package ag.ifpb;

import java.math.BigInteger;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.codehaus.plexus.classworlds.strategy.StrategyFactory;

import ag.ifpb.impl.EncrypterFactoryImpl;

public class Main {
	
	private static int[] extractKeys(String ks){
		String[] keys = ks.split(",");
		//check if array
		if (keys == null || keys.length != 3) 
			throw new IllegalArgumentException("As chaves são obrigatórias");
		//check if hex-string
		for (String k : keys) {
			if (!k.matches("[0-9a-f]{6}"))
				throw new IllegalArgumentException("Chave inválida. Uma chave é representada por um hexadecimal de 6 digitos");
		}
		//convert hex to int
		int ix = 0;
		int[] kis = new int[3];
		for (String k : keys) {
			BigInteger bigInteger = new BigInteger(k, 16);
			kis[ix++] = bigInteger.intValue();
		}
		return kis;
	}
	
	private static String extractText(String args0){
		String text = args0;
		if (text.isEmpty()){
			throw new IllegalArgumentException("Texto inválido. Digite o texto a ser criptografado ou correspondente a uma cifra");
		}
		return text;
	}
		
	private static String extractType(String type) {
		if (!type.matches("^([c]+[d]+)|([d]+[c]+)$"))
			throw new IllegalArgumentException("Tipo de estratégia inválida. Digite um tipo de estratégia válida");
		return type;
	}
		
	private static void execEncryptation(String type, int[] ks, String text) {
		System.out.println("encriptando: " + text);
		EncrypterFactory encrypterFactory = new EncrypterFactoryImpl();
		EncryptionStrategy strategy = encrypterFactory.strategy(EncriptionType.convert(type));
		System.out.println("texto criptografado: " + strategy.encrypt(ks, text));
	}

	private static void execDecryptation(String type, int[] ks, String text) {
		// TODO Auto-generated method stub
		System.out.println("decriptando: " + text);
	}

	public static void main(String[] args) throws ParseException {
		//
		Options options = new Options();
		options.addOption("h", false, "estas informações");
		options.addOption("enc", false, "executa uma criptografia (default)");
		options.addOption("dec", false, "executa uma decriptografia (inválido se usar -enc)");
		options.addOption("type", true, "digite uma das opções: ccd, cdc, dcc, ddc, dcd, cdd");
		options.addOption("ks", true, "lista de chaves de 6 digitos separadas por vírgula e sem espaço. "
				+ "Exemplo: 999999,111111,000000");
		//
		CommandLineParser parser = new DefaultParser();
		try {
			CommandLine cmd = parser.parse(options, args);
			//help
			if (cmd.hasOption("h")){
				HelpFormatter formatter = new HelpFormatter();
				formatter.printHelp("java -jar target/app.jar <options> text", options);
				return;
			}
			//keys
			int[] ks;
			if (cmd.hasOption("ks")){
				ks = extractKeys(cmd.getOptionValue("ks"));
			} else {
				throw new IllegalArgumentException("Chamada com formato inválido. Faltando opção '-ks'");
			}
			//type
			String type;
			if (cmd.hasOption("type")){
				type = extractType(cmd.getOptionValue("type"));
			} else {
				throw new IllegalArgumentException("Chamada com formato inválido. Faltando opção '-type'");
			}
			//text
			String text;
			if (!cmd.getArgList().isEmpty()){
				text = extractText( cmd.getArgList().get(0));
			} else {
				throw new IllegalArgumentException("Chamada com formato inválido. Faltando argumento 'text'");
			}
			//dec
			if (cmd.hasOption("dec") && !cmd.hasOption("enc")){
				execDecryptation(type, ks, text);
			} else {
				execEncryptation(type, ks, text);
			}
	    }
	    catch(ParseException exp ) {
	        System.err.println( "Linha de comando incorreta. Razão: " + exp.getMessage() );
	    }
		catch (IllegalArgumentException e) {
			System.err.println(e.getMessage());
			e.printStackTrace();
		}
	}

	

	
	
}
